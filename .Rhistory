#	* feature annotation
## NULL arguments
if(is.null(dmr)){
stop("The argument 'dmr' must be introduced")
}
if(is.null(methy)){
stop("The argument 'beta' must be introduced")
}
if(is.null(genome)){
stop("The argument 'genome' must be introduced")
}
##Unique DMR
# if(nrow(dmr) > 1){
#   warning("more than one DMR introduced (nrow > 1)
#           only the first element will be used")
#   dmr <- dmr[1,]
# }
##Genome assembly
if(genome != "hg38" & genome != "hg19" & genome != "hg18"){
stop("Argument 'genome' must be 'hg38', 'hg19' or 'hg18'")
}
##Epimutation start('from') and end('to') possitions
## * 'from' and 'to' introduced together
if(is.null(from) & !is.null(to) | !is.null(from) & is.null(to)){
stop("Arguments 'from' and 'to' must be provided together")
}
## * 'from' is smaller than 'to'
if(!is.null(from) & !is.null(to)){
if(from > to){
stop("The value of argument 'from' must be smaller than 'to'")
}
}
if (!requireNamespace("grDevices"))
stop("'grDevices' package not avaibale")
# DMR column names must be always
# the same (set the common column names)
# dmr  <- cols_names(dmr, cpg_ids_col = TRUE)  #epi_plot
# Set 'from' and 'to' arguments value
if(is.null(from) & is.null(to)){
from <- dmr$start[1] - 1000
to <- dmr$end[1] + 1000
}
#Generate GenomicRanges object to contain in the same object:
## * Genomic ranges of each CpG in the DMR
## * Beta values
gr <- create_GRanges_class(methy, dmr[,"cpg_ids"][1]) #epi_plot
betas_sd_mean <- betas_sd_mean(gr) #epi_plot
#Generate variables in 'beta_values' data frame containing:
# * status: case sample name/'control'
# * color: 'red' for case sample and 'black' for control sample
# * lines: 'longdash' for controls and
#          'solid' for case and population mean
status <- ifelse(betas_sd_mean$beta_values$variable %in% dmr$sample,
dmr$sample,
"control")
betas_sd_mean$beta_values$status <- status
rm(status)
lines <- ifelse(betas_sd_mean$beta_values$status == "control",
"longdash","solid")
betas_sd_mean$beta_values$lines <- lines
rm(lines)
colors <- c("control" = "black",
"mean" = "darkblue")#,
# "red")
# names(colors)[3] <- dmr$sample
#Generate a variable with the CpGs names
variable <- betas_sd_mean$beta_values$variable
names <- betas_sd_mean$beta_values[variable == dmr$sample,]
rm(variable)
names$id <- names(gr)
#Plot epimutations
plot_betas <- ggplot2::ggplot() +
ggplot2::geom_line(data = betas_sd_mean$beta_values,
ggplot2::aes(x = start,
y = value,
#group = variable,
color = status),
linetype = betas_sd_mean$beta_values$lines) +
ggplot2::geom_point(data = betas_sd_mean$beta_values,
ggplot2::aes(x = start,
y = value,
#group = variable,
color = status))
plot_sd <- plot_betas +
ggplot2::geom_ribbon(data = betas_sd_mean$sd,
ggplot2::aes(x = start,
ymin = sd_2_lower,
ymax = sd_2_upper),
fill = "gray39", alpha = 0.4) +
ggplot2::geom_ribbon(data = betas_sd_mean$sd,
ggplot2::aes(x = start,
ymin = sd_1.5_lower,
ymax = sd_1.5_upper),
fill = "gray40", alpha = 0.4) +
ggplot2::geom_ribbon(data = betas_sd_mean$sd,
ggplot2::aes(x = start,
ymin = sd_1_lower,
ymax = sd_1_upper),
fill = "gray98", alpha = 0.4)
plot_mean <-  plot_sd +
ggplot2::geom_line(data = betas_sd_mean$mean,
ggplot2::aes(x = start,
y = mean,
color = "mean")) +
ggplot2::geom_point(data = betas_sd_mean$mean,
ggplot2::aes(x = start, y = mean),
show.legend = TRUE)
if (requireNamespace("ggrepel", quietly = TRUE)) {
plot_cpg_names <- plot_mean +
ggrepel::geom_text_repel() +
ggplot2::annotate(geom = "text",
x = names$start,
y = names$value + 0.05,
label = names$id,
color = "black")
} else {
stop("'ggrepel' package not avaibale")
}
browser()
plot <- plot_cpg_names +
ggplot2::lims(y = c(0,1)) +
ggplot2::scale_colour_manual(name = "Status", values = colors) +
ggplot2::theme_bw() +
ggplot2::ggtitle(paste0(dmr$sample,": ",
dmr$seqnames, ":",
dmr$start,
" - ", dmr$end)) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
ggplot2::labs(x = "Coordinates") +
ggplot2::labs(y = "DNA methylation level")
#Plot gene annotations
if (requireNamespace("Gviz", quietly = TRUE)){
if(genes_annot == TRUE | regulation == TRUE){
ideo_track <- Gviz::IdeogramTrack(genome = genome,
chromosome = dmr$seqnames)
genome_track <- Gviz::GenomeAxisTrack()
genes <- UCSC_annotation(genome) #epi_plot
gene_track <- Gviz::GeneRegionTrack(genes,
chromosome = dmr$seqnames,
name = "Genes",
transcriptAnnotation = "symbol",
background.title = "#8F913A",
rotation.title = 0)
if(genes_annot == TRUE){
tracks_Highlight <- Gviz::HighlightTrack(trackList =
list(genome_track,
gene_track),
start = dmr$start,
end = dmr$end,
chromosome = dmr$seqnames,
col = "#7EA577",
fill = "#C6D7C3",
alpha = 0.4,
inBackground = FALSE)
}
if(regulation == TRUE){
sz <- to - from
if(sz > 200000){
stop("The region is too large (> 200kb)
to download the annotations from 'UCSC'")
}
annotation <- UCSC_regulation(genome,
dmr$seqnames,
from,
to)
if(genome ==  "hg19"){
tracks_Highlight <- Gviz::HighlightTrack(trackList =
list(genome_track,
gene_track,
annotation$cpgIslands,
annotation$H3K4Me3,
annotation$H3K27Ac,
annotation$H3K27Me3),
start = dmr$start,
end = dmr$end,
chromosome = dmr$seqnames,
col = "#7EA577",
fill = "#C6D7C3",
alpha = 0.4,
inBackground = FALSE)
}else{
tracks_Highlight <- Gviz::HighlightTrack(trackList =
list(genome_track,
gene_track,
annotation$cpgIslands,
annotation$H3K4Me3,
annotation$H3K27Ac),
start = dmr$start,
end = dmr$end,
chromosome = dmr$seqnames,
col = "#7EA577",
fill = "#C6D7C3",
alpha = 0.4,
inBackground = FALSE)
}
}
}
if(genes_annot == TRUE |  regulation == TRUE){
#Plot window
#dev.new(width = 1080, height = 1350, unit = "px")
p1 <- plot
if (requireNamespace("grid", quietly = TRUE)) {
p2 <- grid::grid.grabExpr(Gviz::plotTracks(list(ideo_track,
tracks_Highlight),
from = from,
to = to, add = TRUE))
} else {
stop("'grid' package not avaibale")
}
if (requireNamespace("gridExtra", quietly = TRUE)) {
return(cowplot::plot_grid(plot, cowplot::ggdraw() + cowplot::draw_grob(p2), ncol = 1))
# gridExtra::grid.arrange(grobs = list(p1,p2), row = 2)
} else {
stop("'gridExtra' package not avaibale")
}
}else{
plot
}
}else{
}
}
plot_epimutations(as.data.frame(epi_mvo[epi_mvo$epi_region_id == "chr7_27186554",]), methy)
plot_cpg_names
plot <- plot_cpg_names +
ggplot2::lims(y = c(0,1)) +
ggplot2::scale_colour_manual(name = "Status", values = colors) +
ggplot2::theme_bw() +
ggplot2::ggtitle(paste0(dmr$sample,": ",
dmr$seqnames, ":",
dmr$start,
" - ", dmr$end)) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
ggplot2::labs(x = "Coordinates") +
ggplot2::labs(y = "DNA methylation level")
plot
colors
plot <- plot_cpg_names +
ggplot2::lims(y = c(0,1)) +
# ggplot2::scale_colour_manual(name = "Status", values = colors) +
ggplot2::theme_bw() +
ggplot2::ggtitle(paste0(dmr$sample,": ",
dmr$seqnames, ":",
dmr$start,
" - ", dmr$end)) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
ggplot2::labs(x = "Coordinates") +
ggplot2::labs(y = "DNA methylation level")
plot
dmr$seqnames
dmr$start
paste0(dmr$sample, collapse = ", ")
plot <- plot_cpg_names +
ggplot2::lims(y = c(0,1)) +
# ggplot2::scale_colour_manual(name = "Status", values = colors) +
ggplot2::theme_bw() +
ggplot2::ggtitle(paste0(dmr$sample, collapse = ", ")) +
# ggplot2::ggtitle(paste0(dmr$sample,": ",
#                         dmr$seqnames, ":",
#                         dmr$start,
#                         " - ", dmr$end)) +
ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5)) +
ggplot2::labs(x = "Coordinates") +
ggplot2::labs(y = "DNA methylation level")
plot
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
gr
#Plot epimutations
plot_betas <- ggplot2::ggplot() +
ggplot2::geom_line(data = betas_sd_mean$beta_values,
ggplot2::aes(x = start,
y = value,
#group = variable,
color = status),
linetype = betas_sd_mean$beta_values$lines) +
ggplot2::geom_point(data = betas_sd_mean$beta_values,
ggplot2::aes(x = start,
y = value,
#group = variable,
color = status))
plot_betas
betas_sd_mean$beta_values
#Plot epimutations
plot_betas <- ggplot2::ggplot() +
ggplot2::geom_line(data = betas_sd_mean$beta_values,
ggplot2::aes(x = start,
y = value,
group = variable,
color = status),
linetype = betas_sd_mean$beta_values$lines) +
ggplot2::geom_point(data = betas_sd_mean$beta_values,
ggplot2::aes(x = start,
y = value,
#group = variable,
color = status))
plot_betas
dev.off()
dev.off()
plot_betas
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
betas_sd_mean$beta_values
dmr$sample
length(dmr$sample)
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
tracks_Highlight <- Gviz::HighlightTrack(trackList =
list(genome_track,
gene_track),
start = dmr$start[1],
end = dmr$end[1],
chromosome = dmr$seqnames[1],
col = "#7EA577",
fill = "#C6D7C3",
alpha = 0.4,
inBackground = FALSE)
tracks_Highlight
dmr$start
dmr$start[1]
dmr$seqnames[1]
dmr$seqnames
regulation
#Plot window
#dev.new(width = 1080, height = 1350, unit = "px")
p1 <- plot
p2 <- grid::grid.grabExpr(Gviz::plotTracks(list(ideo_track,
tracks_Highlight),
from = from,
to = to, add = TRUE))
ideo_track
tracks_Highlight
from
to
tracks_Highlight
ideo_track
genome
dmr$seqnames
dmr
gr
dmr
ideo_track <- Gviz::IdeogramTrack(genome = genome,
chromosome = dmr$chromosome[1])
ideo_track
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
tracks_Highlight <- Gviz::HighlightTrack(trackList =
list(genome_track,
gene_track),
start = dmr$start[1],
end = dmr$end[1],
chromosome = dmr$chromosome[1],
col = "#7EA577",
fill = "#C6D7C3",
alpha = 0.4,
inBackground = FALSE)
tracks_Highlight
#Plot window
#dev.new(width = 1080, height = 1350, unit = "px")
p1 <- plot
p2 <- grid::grid.grabExpr(Gviz::plotTracks(list(ideo_track,
tracks_Highlight),
from = from,
to = to, add = TRUE))
p2
dev.off()
p2
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
#options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
